use dep::std::hash::pedersen_hash_slice;
use crate::{verify, add, delete, update};

fn pedersen_hasher(leaves: [Field]) -> Field {
    pedersen_hash_slice(leaves)
}

global TREE_DEPTH = 256;

#[test]
fn test_verify_membership_proof() {
    let root = 10163036226218365628416274178218539053881692695713984759452839539868301499377;
    let key = 20438969296305830531522370305156029982566273432331621236661483041446048135547;
    let value = 17150136040889237739751319962368206600863150289695545292530539263327413090784;
    let entry = [key, value];
    let matching_entry = [Option::none(), Option::none()];
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[253] = 16005544925904787818741660841048975184697157987475781759237359957800253937014;
    siblings[254] = 652515607053222641420986801717363174355390181496524320106921145388058577161;
    siblings[255] = 2708335068696962380008982791185936221130805655713417587265130133162794982262;
    verify(
        entry,
        matching_entry,
        siblings.as_slice(),
        root,
        pedersen_hasher
    );
}

#[test]
fn test_verify_non_membership_proof() {
    let small_tree_root = 10163036226218365628416274178218539053881692695713984759452839539868301499377;
    let key = 20438969296305830531522380305156029982566273432331621236661483041446048135547;
    let value = 17150136040889237739751319962368206600863250289695545292530539263327413090784;
    let entry = [key, value];
    let matching_entry = [
        Option::some(20438969296305830531522370305156029982566273432331621236661483041446048135547),
        Option::some(17150136040889237739751319962368206600863150289695545292530539263327413090784)
    ];
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[253] = 16005544925904787818741660841048975184697157987475781759237359957800253937014;
    siblings[254] = 652515607053222641420986801717363174355390181496524320106921145388058577161;
    siblings[255] = 2708335068696962380008982791185936221130805655713417587265130133162794982262;
    verify(
        entry,
        matching_entry,
        siblings.as_slice(),
        small_tree_root,
        pedersen_hasher
    );
}

#[test]
fn test_add_first_element() {
    let key = 20438969296305830531522370305156029982566273432331621236661483041446048135547;
    let value = 17150136040889237739751319962368206600863150289695545292530539263327413090784;
    let entry = [key, value];
    let siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    let zero_node = 0;
    assert(
        add(entry, zero_node, siblings.as_slice(), pedersen_hasher)
        == 2422708535743783816563452741494007579003622904961533867614614610167375232032
    );
}

#[test]
fn test_add_element_to_one_element_tree() {
    let key = 7374494214024125590767526270082639043919066776944047470878693145844636921798;
    let value = 3315292394704439116482935361251007857050519763420264982454883186141315324846;
    let entry = [key, value];
    let old_root = 2422708535743783816563452741494007579003622904961533867614614610167375232032;
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[255] = 2422708535743783816563452741494007579003622904961533867614614610167375232032;
    assert(
        add(entry, old_root, siblings.as_slice(), pedersen_hasher)
        == 13995819305603022633355680906127521476353407789113491617487780281225566393218
    );
}

#[test]
fn test_add_element_to_existing_tree() {
    let key = 12467743582502009806452203915647380852106587605639139696405928234368558796420;
    let value = 7661601117049907361128926075270530269257730340678343102988736234309528818274;
    let entry = [key, value];
    let root = 13995819305603022633355680906127521476353407789113491617487780281225566393218;
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[254] = 18033090709903916521866304938786912938158112601014366947614987606463992198712;
    siblings[255] = 2422708535743783816563452741494007579003622904961533867614614610167375232032;
    let big_tree_root = 8307334591379324778417663235463648615723981385559143500721691536202573318888;
    assert(add(entry, root, siblings.as_slice(), pedersen_hasher) == big_tree_root);
}

#[test]
fn test_delete() {
    let key = 12467743582502009806452203915647380852106587605639139696405928234368558796420;
    let value = 7661601117049907361128926075270530269257730340678343102988736234309528818274;
    let entry = [key, value];
    let big_tree_root = 8307334591379324778417663235463648615723981385559143500721691536202573318888;
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[254] = 18033090709903916521866304938786912938158112601014366947614987606463992198712;
    siblings[255] = 2422708535743783816563452741494007579003622904961533867614614610167375232032;
    let small_tree_root = 13995819305603022633355680906127521476353407789113491617487780281225566393218;
    assert(delete(entry, big_tree_root, siblings.as_slice(), pedersen_hasher) == small_tree_root);
}

#[test]
fn test_update() {
    let key = 12467743582502009806452203915647380852106587605639139696405928234368558796420;
    let old_value = 7661601117049907361128926075270530269257730340678343102988736234309528818274;
    let new_value = 7661601117049907361128926075270530269257730340678343102988736234309528818275;
    let old_entry = [key, old_value];
    let old_root = 8307334591379324778417663235463648615723981385559143500721691536202573318888;
    let mut siblings: [Field; TREE_DEPTH] = [0; TREE_DEPTH];
    siblings[254] = 18033090709903916521866304938786912938158112601014366947614987606463992198712;
    siblings[255] = 2422708535743783816563452741494007579003622904961533867614614610167375232032;
    let big_tree_root = 15109801937676825792951435733056938044336635984778954078779396173428619028936;
    assert(
        update(
        new_value,
        old_entry,
        old_root,
        siblings.as_slice(),
        pedersen_hasher
    )
        == big_tree_root
    );
}
